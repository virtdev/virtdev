#!/usr/bin/node

var mqtt = require('mqtt');
var crypto = require("crypto");
var WebSocketClient = require('websocket').client;
var wrtc = require('electron-webrtc')({ headless: true });

var RTCIceCandidate = wrtc.RTCIceCandidate;
var RTCPeerConnection = wrtc.RTCPeerConnection;
var RTCSessionDescription = wrtc.RTCSessionDescription;
var argv = require('minimist')(process.argv.slice(2));

var sourceKey = argv.k;
var sourceAddr = argv.a;
var bridgeAddr = argv.b;
var bridgePort = argv.p;
var conductorPort = argv.c;
var websocketPort = argv.l;

var visible = true;
var localhost = '127.0.0.1';
var listeners = new Object();
var connections = new Object();
var configuration = {
  iceServers: [
    {url:'stun:stun.gmx.net:3478'},
    {url:'stun:stun.voxgratia.org'},
    {url:'stun:stun.ekiga.net'},
  ]
};

function log(str)
{
  if (visible)
    console.log(str);
}

function encrypt(args, key)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var data = JSON.stringify(args);
  var encipher = crypto.createCipheriv('aes-128-cbc', k, iv);
  var res = encipher.update(data, 'utf8', 'binary');

  return res + encipher.final('binary');
}

function decrypt(data, k, iv)
{
  var decipher = crypto.createDecipheriv('aes-128-cbc', k, iv);
  var res = decipher.update(data, 'binary', 'utf8');

  return res + decipher.final('utf8');
}

function openChannel(addr, key, bridge, source)
{
  var pc = new RTCPeerConnection(configuration);
  
  if (addr in connections)
    closeChannel(addr);

  connections[addr] = new Object();
  connections[addr].listener = source.addr;  
  connections[addr].ready = false;
  connections[addr].pc = pc;
  
  var channel = pc.createDataChannel('sendDataChannel', {
    reliable: true 
  });
  
  channel.binaryType = 'arraybuffer';
  channel.onopen = function() {
    log('openChannel: onopen, addr=' + addr);
    connections[addr].channel = channel;
    connections[addr].ready = true;
    channel.onmessage = function(event) {
      var client = new WebSocketClient();
      
      client.on('connect', function(connection) {
        if (connection.connected)
          connection.sendUTF(event.data);
      });
      client.connect('ws://' + localhost + ':' + conductorPort);
    };
  };
  
  channel.onclose = function () {
    log('openChannel: onclose, addr=' + addr);
  };

  pc.onicecandidate = function(event) {
    if (event.candidate) {
      var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
      
      client.on('connect', function () {
        var args = new Object();
        
        args.cmd = 'candidate';
        args.addr = source.addr;
        args.cand = event.candidate;
        client.publish(addr, encrypt(args, key));
        client.end();
      });
    }
  };
  
  pc.createOffer(setLocalDesc);
  function setLocalDesc(desc) {
    pc.setLocalDescription(
      new RTCSessionDescription(desc), 
      setRemoteDesc.bind(undefined, desc)
    );
  }
  
  function setRemoteDesc(desc) {
    var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);

    client.on('connect', function () {
      var args = new Object();

      args.cmd = 'prepare';
      args.key = source.key;
      args.addr = source.addr;
      args.bridge = source.bridge;
      args.desc = {'type': desc.type, 'sdp': desc.sdp};
      client.publish(addr, encrypt(args, key));
      client.end();
    });
  }
  
  log("openChannel: addr=" + addr);
}

function closeChannel(addr) 
{
  if (addr in connections) {
    log("closeChannel: addr=" + addr);
    connections[addr].pc.close();
    delete connections[addr];
  }
}

function prepareChannel(addr, key, offer, bridge, listener)
{
  var pc = new RTCPeerConnection(configuration);
  
  if (addr in connections)
    closeChannel(addr);
  
  connections[addr] = new Object();
  connections[addr].listener = listener;
  connections[addr].ready = false;
  connections[addr].pc = pc;
  
  pc.ondatachannel = function(event) {
    var channel = event.channel;
    
    channel.onopen = function() {
      log('prepareChannel: onopen, addr=' + addr);
      connections[addr].ready = true;
      channel.onmessage = function(event) {
        var client = new WebSocketClient();

        client.on('connect', function(connection) {
          if (connection.connected)
            connection.sendUTF(event.data);
        });
        client.connect('ws://' + localhost + ':' + conductorPort);
      };
    };
    
    channel.onclose = function() {
      log('prepareChannel: onclose, addr=' + addr);
      closeChannel(addr);
    }
    connections[addr] = channel;
  };

  pc.onicecandidate = function(event) {
    if (event.candidate) {
      var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
      
      client.on('connect', function () {
        var args = new Object();
        
        args.cmd = 'candidate';
        args.addr = listener;
        args.cand = event.candidate;
        client.publish(addr, encrypt(args, key));
        client.end();
      });
    }
  };
  
  pc.setRemoteDescription(
    new RTCSessionDescription(offer),
    createAnswer
  );
  
  function createAnswer() {
    pc.createAnswer(setLocalDesc);
  }    
  
  function setLocalDesc(desc) {
    pc.setLocalDescription(
      new RTCSessionDescription(desc),
      answer.bind(undefined, desc)
    );
  }
  
  function answer(desc) {
    var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);

    client.on('connect', function () {
      var args = new Object();

      args.desc = desc;
      args.cmd = 'create';
      args.addr = listener;
      client.publish(addr, encrypt(args, key));
      client.end();
    });
  }
  log('prepareChannel: addr=' + addr);
}

function addCandidate(addr, cand, listener)
{
  if (addr in connections && cand && connections[addr].listener == listener) {
    var candidate = new RTCIceCandidate(cand);

    connections[addr].pc.addIceCandidate(candidate);
    log('addCandidate: addr=' + addr);
  }
}

function createChannel(addr, desc, listener)
{
  if (addr in connections && connections[addr].listener == listener) {
    connections[addr].pc.setRemoteDescription(new RTCSessionDescription(desc));
    log('createChannel: addr=' + addr);
  }
}

function writeChannel(addr, buf)
{
  if (addr in connections && connections[addr].ready && buf) {
    connections[addr].channel.send(buf);
    log('writeChannel: addr=' + addr);
  }
}

function attachChannel(addr, key, bridge)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);

  client.on('connect', function() {
    client.subscribe(addr);
  });

  client.on('message', function(topic, message) {
    var data = decrypt(message.toString(), k, iv);
    var args = JSON.parse(data);

    if ('prepare' == args.cmd) {
      prepareChannel(args.addr, args.key, args.desc, args.bridge, addr);
    } else if ('create' == args.cmd) {
      createChannel(args.addr, args.desc, addr);
    } else if ('candidate' == args.cmd) {
      addCandidate(args.addr, args.cand, addr);
    } else
      log('Error: failed to attach channel, invalid command');
  });

  listeners[addr] = client;
  log("attachChannel: addr=" + addr);
}

function detachChannel(addr)
{
  var client = listeners[addr];

  if (client) {
    log("detachChannel: addr=" + addr);
    client.unsubscribe(addr);
    client.end();
    delete listeners[addr];
  }
}

function existChannel(addr, socket)
{
  if (addr in connections && connections[addr].ready) {
    log('existChannel: addr=' + addr);
    socket.send('exist');
  } else
    socket.send('');
}

if (sourceAddr) {
  attachChannel(sourceAddr, sourceKey, bridgeAddr);
}

if (websocketPort) {
  var source = new Object();
  var websocket = require('ws');
  var server = new websocket.Server({'port': websocketPort});

  if (sourceAddr) {
    source.key = sourceKey;
    source.addr = sourceAddr;
    source.bridge = bridgeAddr;
  }

  server.on('connection', function(socket) {
    socket.on('message', function(data) {
      var args = JSON.parse(data);

      if ('open' == args.cmd) {
        if (args.source)
          openChannel(args.addr, args.key, args.bridge, args.source);
        else
          openChannel(args.addr, args.key, args.bridge, source);
      } else if ('write' == args.cmd) {
        writeChannel(args.addr, args.buf);
      } else if ('close' == args.cmd) {
        closeChannel(args.addr);
      } else if ('attach' == args.cmd) {
        attachChannel(args.addr, args.key, args.bridge);
      } else if ('detach' == args.cmd) {
        detachChannel(args.addr);
      } else if ('exist' == args.cmd) {
        existChannel(args.addr, socket);
      } else
        log("Error: invalid command");
    });
  });
}
