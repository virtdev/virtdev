#!/usr/bin/node

// Copyright (C) 2016 Yi-Wei Ci
//
// Distributed under the terms of the MIT license.
//

var mqtt = require('mqtt');
var crypto = require("crypto");
var uuid = require('node-uuid');
var wrtc = require('electron-webrtc')();
var SimplePeer = require('simple-peer');
var WebSocketClient = require('websocket').client;
var argv = require('minimist')(process.argv.slice(2));

var eventPort = argv.e;
var sourceKey = argv.k;
var sourceAddr = argv.a;
var bridgeAddr = argv.b;
var bridgePort = argv.p;
var adapterPort = argv.l;
var conductorPort = argv.c;
var sendTimeout = parseInt(argv.t) * 1000; //msec

var debug = true;
var pktMark = '|';

var minLen = 10;
var waitTime = 50; // msec
var chunkSize = 65536;
var localhost = '127.0.0.1';
var highWaterMark = 1 << 24;
var lowWaterMark = highWaterMark / 2;
var waterMark = (highWaterMark + lowWaterMark) / 2;

var listeners = new Object();
var connections = new Object();
var peerConnections = new Object();

var peerConnectionConfig = {
  iceServers: [
    {url:'stun:stun.ekiga.net'}
  ]
};

var dataChannelConfig = {
  ordered: true,
  reliable: false,
  maxRetransmitTime: 3000
};

function log(str)
{
  if (debug)
    console.log('wrtc: ' + str);
}

function error(str)
{
  console.log('wrtc: ' + str);
}

function encrypt(args, key)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var data = JSON.stringify(args);
  var encipher = crypto.createCipheriv('aes-128-cbc', k, iv);
  var res = encipher.update(data, 'utf8', 'binary');
  
  return res + encipher.final('binary');
}

function decrypt(data, k, iv)
{
  var decipher = crypto.createDecipheriv('aes-128-cbc', k, iv);
  var res = decipher.update(data, 'binary', 'utf8');
  
  return res + decipher.final('utf8');
}

function isReady(addr)
{
  if ((addr in connections) && connections[addr].ready)
    return true;
  else
    return false;
}

function forward(data)
{
  var client = new WebSocketClient();
  
  client.on('connect', function(connection) {
    if (connection.connected)
      connection.sendUTF(data);
  });
  
  client.connect('ws://' + localhost + ':' + conductorPort);
}

function emit(event, args)
{
  var client = new WebSocketClient();
  
  client.on('connect', function(connection) {
    if (connection.connected) {
      var res = new Object();
      
      res.args = args;
      res.event = event;
      
      connection.sendUTF(JSON.stringify(res));
    }
  });
  
  client.connect('ws://' + localhost + ':' + eventPort);
}

function notify(addr, key, bridge, args)
{
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function () {
    client.publish(addr, encrypt(args, key));
    client.end();
  });
}

function newPkt(buf)
{
  if (buf.indexOf(pktMark) != -1) {
    error('failed to create a packet');
    return;
  }
  
  return buf + pktMark;
}

function int2hex(val)
{
  var hex = val.toString(16);
  
  return "00000000".substr(0, 8 - hex.length) + hex; 
}

function newAckPkt(index)
{
  return pktMark + int2hex(index) + pktMark;
}

function newIndexedPkt(addr, buf)
{
  if (buf.indexOf(pktMark) != -1) {
    error('failed to create an indexed packet, addr=' + addr);
    return;
  }
  
  if (!connections[addr].count) {
    connections[addr].ack = new Object();
    connections[addr].count = 1;
  } else
    connections[addr].count += 1;
  
  var index = connections[addr].count; 
  var data = pktMark + int2hex(index) + buf + pktMark;
  
  connections[addr].ack[index] = false;
  return {'index':index, 'data':data};
}

function checkPkt(addr, index)
{
  if (peerConnections[addr].buf)
    delete peerConnections[addr].buf;
  
  if (!peerConnections[addr].index || (index > peerConnections[addr].index)) {
    peerConnections[addr].index = index;
    return true;
  } else
    return false;
}

function updatePkt(addr, buf)
{
  if (peerConnections[addr].buf)
    peerConnections[addr].buf += buf;
  else
    peerConnections[addr].buf = buf;
}

function deliver(addr, buf)
{
  var index = peerConnections[addr].index;
  
  if (peerConnections[addr].buf)
    buf = peerConnections[addr].buf + buf;
  
  forward(buf);
  
  if (index)
    peerConnections[addr].peer.send(newAckPkt(index));
  
  if (peerConnections[addr].buf)
    delete peerConnections[addr].buf;
}

function deliverPkt(addr, buf)
{
  buf = String(buf);
  if (buf.startsWith(pktMark)) {
    if (buf.length < minLen) {
      error("failed to deliver, invalid packet");
      return;
    }
    
    var index = Number('0x' + buf.substring(1, minLen - 1));
    
    if ((buf.length == minLen) && buf.endsWith(pktMark)) {
      if (isReady(addr) && (index in connections[addr].ack)) {
        if (!connections[addr].ack[index]) {
          connections[addr].ack[index] = true;
          emit('put', {'name': addr});
          log('ack, addr=' + addr + ', index=' + index.toString());
        }
      }
    } else if (checkPkt(addr, index)) {
      if (buf.endsWith(pktMark)) {
        deliver(addr, buf.substring(minLen - 1, buf.length - 1));
      } else {
        updatePkt(addr, buf.substring(minLen - 1, buf.length));
      }
    }
  } else if (buf.endsWith(pktMark)) {
    deliver(addr, buf.substring(0, buf.length - 1));
  } else {
    updatePkt(addr, buf);
  }
}

function join(dest, src)
{ 
  var id = src.id;
  var key = src.key;
  var addr = src.addr;
  var desc = src.desc;
  var bridge = src.bridge;
  
  if (!id || !key || !addr || !desc || !bridge) {
    error('failed to join, invalid arguments');
    return;
  }
  
  if (addr in peerConnections) {
    if (peerConnections[addr].id != id) {
      var peer = peerConnections[addr].peer;
      
      delete peerConnections[addr];
      peer.destroy();
      log('join, clear connection, addr=' + addr);
    } else {
      peerConnections[addr].peer.signal(desc);
      return;
    }
  }
  
  var peer = new SimplePeer({
    wrtc: wrtc,
    highWaterMark: highWaterMark,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  peerConnections[addr] = new Object();
  peerConnections[addr].peer = peer;
  peerConnections[addr].id = id;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.id = id;
    args.addr = dest;
    args.desc = data;
    args.cmd = 'response';
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('data', function (data) {
    if (data)
      deliverPkt(addr, data);
  });
  
  peer.on('close', function() {
    if ((addr in peerConnections) && (peerConnections[addr].id == id))
      delete peerConnections[addr];
  });
  
  peer.on('error', function (err) {
    if ((addr in peerConnections) && (peerConnections[addr].id == id)) {
      delete peerConnections[addr];
      peer.destroy();
      error('join, connection is lost, addr=' + addr);
    }
  });
  
  peer.signal(desc);
  log('join, addr=' + addr);
}

function response(dest)
{
  var id = dest.id;
  var addr = dest.addr;
  var desc = dest.desc;
  
  if (!addr || !desc || !id) {
    error('failed to response, invalid arguments');
    return;
  }
  
  if ((addr in connections) && (connections[addr].id == id))
    connections[addr].peer.signal(desc);
}

function open(addr, key, bridge, source)
{ 
  if (addr in connections) {
    if (connections[addr].src != source.addr) {
      var peer = connections[addr].peer;
      
      delete connections[addr];
      peer.destroy();
      log('open, clear connection, addr=' + addr);
    } else {
      if (connections[addr].ready) {
      	emit('connect', {'name':addr});
        log('open, exist connection, addr=' + addr);
      }
      
      return;
    }
  }
  
  var id = uuid.v4();
  var peer = new SimplePeer({
    wrtc: wrtc,
    initiator: true,
    highWaterMark: highWaterMark,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  connections[addr] = new Object();
  connections[addr].src = source.addr;
  connections[addr].ready = false;
  connections[addr].peer = peer;
  connections[addr].id = id;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.id = id;
    args.desc = data;
    args.cmd = 'join';
    args.key = source.key;
    args.addr = source.addr;
    args.bridge = source.bridge;
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('connect', function () {
    if ((addr in connections) && (connections[addr].id == id)) {
      connections[addr].ready = true;
      emit('connect', {'name':addr});
    }
  });
  
  peer.on('close', function() {
    if ((addr in connections) && (connections[addr].id == id))
      delete connections[addr];
  });
  
  peer.on('error', function (err) {
    if ((addr in connections) && (connections[addr].id == id)) {
      delete connections[addr];
      peer.destroy();
      error('open, connection is lost, addr=' + addr);
    }
  });
  
  if (source.listen) {
    peer.on('data', function (data) {
      if (data)
        deliverPkt(addr, data);
    });
  }
  
  log('open, addr=' + addr);
}

function close(addr) 
{
  if (addr in connections) {
    var peer = connections[addr].peer;
    
    delete connections[addr];
    peer.destroy();
    
    log("close, addr=" + addr);
  }
}

function chunkify(addr, buf, event)
{
  if (chunkSize) {
    buf = String(buf);
    var length = buf.length;
    var start = 0;
    
    while (start < length) {
      var l = start + chunkSize <= length ? chunkSize : length - start;
      
      if (isReady(addr)) {
        var data = buf.substring(start, start + l);
        
        connections[addr].peer.send(data);
        start += l;
      } else {
        emit(event, {'name':addr, 'error':-2});
        log('failed to chunkify, addr=' + addr);
      }
    }
  } else {
    if (isReady(addr))
      connections[addr].peer.send(buf);
    else {
      emit(event, {'name':addr, 'error':-2});
      log('failed to chunkify, addr=' + addr);
    }
  }
}

function addCallback(addr, pkt, callback, event)
{
  var t = 0;
  var intv = setInterval(function() {
    if (!isReady(addr)) {
      clearInterval(intv);
      emit(event, {'name':addr, 'error':-2});
      log('connection is lost, addr=' + addr);
    } else {
      var size = connections[addr].peer.bufferSize;
      
      t += waitTime;
      if ((t + waitTime >= sendTimeout) || (size < lowWaterMark)) {
        clearInterval(intv);
        if (size < waterMark)
          callback(addr, pkt);
        else
          emit(event, {'name':addr, 'error':-101});
      }
    }
  }, waitTime);
}

function sendPkt(addr, pkt)
{
  chunkify(addr, pkt, 'send');
  emit('send', {'name':addr});
  log('sendPkt, addr=' + addr);
}

function send(addr, buf)
{
  if (isReady(addr)) {
    if (buf) {
      var pkt = newPkt(buf);
      
      if (!pkt)
        return;
      
      if (!sendTimeout || (connections[addr].peer.bufferSize < lowWaterMark))
        sendPkt(addr, pkt);
      else
        addCallback(addr, pkt, sendPkt, 'send');
    }
  } else
    emit('send', {'name':addr, 'error':-2});
}

function waitAck(addr, pkt)
{
  var t = 0;
  var index = pkt.index;
  var timeout = sendTimeout;
  var intv = setInterval(function () {
    if (!isReady(addr)) {
      clearInterval(intv);
      emit('put', {'name':addr, 'error':-2});
      log('cannot get ack, connection is lost, addr=' + addr);
    } else {
      var ack = connections[addr].ack[index];
      
      t += waitTime;
      if (ack || (t >= timeout)) {
        clearInterval(intv);
        delete connections[addr].ack[index];
        if (!ack)
          emit('put', {'name':addr, 'error':-101});
      }
    }
  }, waitTime);
}

function putPkt(addr, pkt)
{
  chunkify(addr, pkt.data, 'put');
  waitAck(addr, pkt);
  log('putPkt, addr=' + addr);
}

function put(addr, buf)
{
  if (isReady(addr)) {
    if (buf) {
      var pkt = newIndexedPkt(addr, buf);
      
      if (!pkt) {
        error('failed to put, invalid data, addr=' + addr);
        return;
      }
      
      if (!sendTimeout || (connections[addr].peer.bufferSize < lowWaterMark))
        putPkt(addr, pkt);
      else
        addCallback(addr, pkt, putPkt, 'put');
    }
  } else
    emit('put', {'name':addr, 'error':-2});
}

function attach(addr, key, bridge)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function() {
    client.subscribe(addr);
  });
  
  client.on('message', function(topic, message) {
    var data = decrypt(message.toString(), k, iv);
    var args = JSON.parse(data);
    
    if ('join' == args.cmd) {
      join(addr, args);
    } else if ('response' == args.cmd) {
      response(args);
    } else
      error('failed to attach, invalid command');
  });
  
  listeners[addr] = client;
}

function detach(addr)
{ 
  if (addr in listeners) {
    var client = listeners[addr];
    
    delete listeners[addr];
    client.unsubscribe(addr);
    client.end();
    log('detach, addr=' + addr);
  }
}

function exist(addr)
{
  if (isReady(addr)) {
    emit('exist', {'name':addr});
    log('exist, addr=' + addr);
  } else {
    emit('exist', {'name':addr, 'error':-2});
    log("exist, error=-2, addr=" + addr);
  }
}

if (sourceAddr) {
  attach(sourceAddr, sourceKey, bridgeAddr);
}

if (adapterPort) {
  var source = new Object();
  var websocket = require('ws');
  var server = new websocket.Server({'port': adapterPort});
  
  if (sourceAddr) {
    source.listen = true;
    source.key = sourceKey;
    source.addr = sourceAddr;
    source.bridge = bridgeAddr;
  }
  
  server.on('connection', function(socket) {
    socket.on('message', function(data) {
      var args = JSON.parse(data);
      
      if (!args.source)
        args.source = source;
      
      if ('open' == args.cmd) {
        open(args.addr, args.key, args.bridge, args.source);
      } else if ('close' == args.cmd) {
        close(args.addr);
      } else if ('attach' == args.cmd) {
        attach(args.addr, args.key, args.bridge);
      } else if ('detach' == args.cmd) {
        detach(args.addr);
      } else if ('exist' == args.cmd) {
        exist(args.addr);
      } else if ('send' == args.cmd) {
        send(args.addr, args.buf);
      } else if ('put' == args.cmd) {
        put(args.addr, args.buf);
      }else
        error("invalid command");
    });
  });
}
