#!/usr/bin/node

var mqtt = require('mqtt');
var crypto = require("crypto");
var wrtc = require('electron-webrtc')();
var WebSocketClient = require('websocket').client;

var RTCIceCandidate = wrtc.RTCIceCandidate;
var RTCPeerConnection = wrtc.RTCPeerConnection;
var RTCSessionDescription = wrtc.RTCSessionDescription;
var argv = require('minimist')(process.argv.slice(2));

var eventPort = argv.e;
var sourceKey = argv.k;
var sourceAddr = argv.a;
var bridgeAddr = argv.b;
var bridgePort = argv.p;
var conductorPort = argv.c;
var websocketPort = argv.l;

var debug = false;
var localhost = '127.0.0.1';
var accepted = new Object();
var listeners = new Object();
var connections = new Object();

var peerConnectionConfig = {
  iceServers: [
    {url:'stun:stun.ekiga.net'}
  ]
};
var peerConnectionOptions = {
  optional: [
    {RtpDataChannels: true},
    {DtlsSrtpKeyAgreement: false}
  ]
};
var dataChannelOptions = {
  ordered: false
};

function log(str)
{
  if (debug)
    console.log(str);
}

function encrypt(args, key)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var data = JSON.stringify(args);
  var encipher = crypto.createCipheriv('aes-128-cbc', k, iv);
  var res = encipher.update(data, 'utf8', 'binary');
  
  return res + encipher.final('binary');
}

function decrypt(data, k, iv)
{
  var decipher = crypto.createDecipheriv('aes-128-cbc', k, iv);
  var res = decipher.update(data, 'binary', 'utf8');
  
  return res + decipher.final('utf8');
}

function openChannel(addr, key, bridge, source)
{
  if (addr in connections)
    closeChannel(addr);
  
  var pc = new RTCPeerConnection(peerConnectionConfig, peerConnectionOptions);
  var channel = pc.createDataChannel('RTCDataChannel', dataChannelOptions);
  
  connections[addr] = new Object();
  connections[addr].listener = source.addr;  
  connections[addr].ready = false;
  connections[addr].pc = pc;
  
  channel.binaryType = 'arraybuffer';
  
  channel.onopen = function() {
    log('openChannel: onopen, ' + addr);
    connections[addr].channel = channel;
    connections[addr].ready = true;
    
    if (eventPort) {
      var client = new WebSocketClient();
      
      client.on('connect', function(connection) {
        if (connection.connected) {
          connection.sendUTF(addr);
        }
      });
      
      client.connect('ws://' + localhost + ':' + eventPort);
    }
    
    channel.onmessage = function(event) {
      var client = new WebSocketClient();
      
      client.on('connect', function(connection) {
        if (connection.connected)
          connection.sendUTF(event.data);
      });
      
      client.connect('ws://' + localhost + ':' + conductorPort);
    };
  };
  
  channel.onclose = function () {
    log('openChannel: onclose, addr=' + addr);
  };
  
  pc.onicecandidate = function(event) {
    if (event.candidate) {
      var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
      
      client.on('connect', function () {
        var args = new Object();
        
        args.cmd = 'addSource';
        args.addr = source.addr;
        args.cand = event.candidate;
        
        client.publish(addr, encrypt(args, key));
        client.end();
      });
    }
  };
  
  pc.createOffer(setLocalDesc);
  
  function setLocalDesc(desc) {
    pc.setLocalDescription(
      new RTCSessionDescription(desc), 
      setRemoteDesc.bind(undefined, desc)
    );
  }
  
  function setRemoteDesc(desc) {
    var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
    
    client.on('connect', function () {
      var args = new Object();
      
      args.cmd = 'prepare';
      args.key = source.key;
      args.addr = source.addr;
      args.bridge = source.bridge;
      args.desc = {'type': desc.type, 'sdp': desc.sdp};
      
      client.publish(addr, encrypt(args, key));
      client.end();
    });
  }
  
  log("openChannel: addr=" + addr);
}

function closeChannel(addr) 
{
  if (addr in connections) {
    log("closeChannel: addr=" + addr);
    connections[addr].pc.close();
    delete connections[addr];
  }
}

function prepareChannel(addr, key, offer, bridge, listener)
{ 
  if (addr in accepted) {
    accepted[addr].pc.close();
    delete accepted[addr];
  }
  
  var pc = new RTCPeerConnection(peerConnectionConfig, peerConnectionOptions);
  
  accepted[addr] = new Object();
  accepted[addr].listener = listener;
  accepted[addr].pc = pc;
  
  pc.ondatachannel = function(event) {
    var channel = event.channel;
    
    channel.onopen = function() {
      log('prepareChannel: onopen, addr=' + addr);
      channel.onmessage = function(event) {
        var client = new WebSocketClient();
        
        client.on('connect', function(connection) {
          if (connection.connected)
            connection.sendUTF(event.data);
        });
        
        client.connect('ws://' + localhost + ':' + conductorPort);
      };
    };
    
    channel.onclose = function() {
      log('prepareChannel: onclose, addr=' + addr);
      if (addr in accepted)
        delete accepted[addr];
    }
  };
  
  pc.onicecandidate = function(event) {
    if (event.candidate) {
      var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
      
      client.on('connect', function () {
        var args = new Object();
        
        args.cmd = 'addPeer';
        args.addr = listener;
        args.cand = event.candidate;
        
        client.publish(addr, encrypt(args, key));
        client.end();
      });
    }
  };
  
  pc.setRemoteDescription(
    new RTCSessionDescription(offer),
    createAnswer
  );
  
  function createAnswer() {
    pc.createAnswer(setLocalDesc);
  }    
  
  function setLocalDesc(desc) {
    pc.setLocalDescription(
      new RTCSessionDescription(desc),
      answer.bind(undefined, desc)
    );
  }
  
  function answer(desc) {
    var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
    
    client.on('connect', function () {
      var args = new Object();
      
      args.desc = desc;
      args.cmd = 'create';
      args.addr = listener;
      
      client.publish(addr, encrypt(args, key));
      client.end();
    });
  }
  
  log('prepareChannel: addr=' + addr);
}

function addSource(addr, candidate, listener)
{
  if (candidate) {
    if (addr in accepted && accepted[addr].listener == listener) {
      var cand = new RTCIceCandidate(candidate);
	  
      accepted[addr].pc.addIceCandidate(cand);
    }
  } else
    log('addSource: invalid candidate');
}

function addPeer(addr, candidate, listener)
{
  if (candidate) {
    if (addr in connections && connections[addr].listener == listener) {
      var cand = new RTCIceCandidate(candidate);
      
      connections[addr].pc.addIceCandidate(cand);
    }
  } else
    log('addPeer: invalid candidate');
}

function createChannel(addr, desc, listener)
{
  if (addr in connections && connections[addr].listener == listener && desc) {
    log('createChannel: addr=' + addr);
    connections[addr].pc.setRemoteDescription(new RTCSessionDescription(desc));
  }
}

function writeChannel(addr, buf)
{
  if (addr in connections && connections[addr].ready && buf) {
    log('writeChannel: addr=' + addr);
    connections[addr].channel.send(buf);
  }
}

function attachChannel(addr, key, bridge)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function() {
    client.subscribe(addr);
  });
  
  client.on('message', function(topic, message) {
    var data = decrypt(message.toString(), k, iv);
    var args = JSON.parse(data);
    
    if ('prepare' == args.cmd) {
      prepareChannel(args.addr, args.key, args.desc, args.bridge, addr);
    } else if ('create' == args.cmd) {
      createChannel(args.addr, args.desc, addr);
    } else if ('addSource' == args.cmd) {
      addSource(args.addr, args.cand, addr);
    } else if ('addPeer' == args.cmd) {
      addPeer(args.addr, args.cand, addr);
    } else
      log('Error: failed to attach channel, invalid command');
  });
  
  listeners[addr] = client;
  log("attachChannel: addr=" + addr);
}

function detachChannel(addr)
{
  var client = listeners[addr];
  
  if (client) {
    log("detachChannel: addr=" + addr);
    client.unsubscribe(addr);
    client.end();
    delete listeners[addr];
  }
}

function existChannel(addr, socket)
{
  if (addr in connections && connections[addr].ready) {
    log('existChannel: addr=' + addr);
    socket.send('exist');
  } else
    socket.send('');
}

if (sourceAddr) {
  attachChannel(sourceAddr, sourceKey, bridgeAddr);
}

if (websocketPort) {
  var source = new Object();
  var websocket = require('ws');
  var server = new websocket.Server({'port': websocketPort});
  
  if (sourceAddr) {
    source.key = sourceKey;
    source.addr = sourceAddr;
    source.bridge = bridgeAddr;
  }
  
  server.on('connection', function(socket) {
    socket.on('message', function(data) {
      var args = JSON.parse(data);
      
      if ('open' == args.cmd) {
        if (args.source)
          openChannel(args.addr, args.key, args.bridge, args.source);
        else
          openChannel(args.addr, args.key, args.bridge, source);
      } else if ('write' == args.cmd) {
        writeChannel(args.addr, args.buf);
      } else if ('close' == args.cmd) {
        closeChannel(args.addr);
      } else if ('attach' == args.cmd) {
        attachChannel(args.addr, args.key, args.bridge);
      } else if ('detach' == args.cmd) {
        detachChannel(args.addr);
      } else if ('exist' == args.cmd) {
        existChannel(args.addr, socket);
      } else
        log("Error: invalid command");
    });
  });
}
