#!/usr/bin/node

var mqtt = require('mqtt');
var crypto = require("crypto");
var wrtc = require('electron-webrtc')();
var SimplePeer = require('simple-peer');
var WebSocketClient = require('websocket').client;
var argv = require('minimist')(process.argv.slice(2));

var eventPort = argv.e;
var sourceKey = argv.k;
var sourceAddr = argv.a;
var bridgeAddr = argv.b;
var bridgePort = argv.p;
var adapterPort = argv.l;
var conductorPort = argv.c;

var debug = false;
var localhost = '127.0.0.1';
var listeners = new Object();
var connections = new Object();

var peerConnectionConfig = {
  iceServers: [
    {url:'stun:stun.ekiga.net'}
  ]
};

var dataChannelConfig = {
  ordered: true,
  reliable: true
};

function log(str)
{
  if (debug)
    console.log('wrtc: ' + str);
}

function encrypt(args, key)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var data = JSON.stringify(args);
  var encipher = crypto.createCipheriv('aes-128-cbc', k, iv);
  var res = encipher.update(data, 'utf8', 'binary');
  
  return res + encipher.final('binary');
}

function decrypt(data, k, iv)
{
  var decipher = crypto.createDecipheriv('aes-128-cbc', k, iv);
  var res = decipher.update(data, 'binary', 'utf8');
  
  return res + decipher.final('utf8');
}

function forward(data)
{
  var client = new WebSocketClient();
  
  client.on('connect', function(connection) {
    if (connection.connected)
      connection.sendUTF(data);
  });
  
  client.connect('ws://' + localhost + ':' + conductorPort);
}

function trigger(data)
{
  var client = new WebSocketClient();
  
  client.on('connect', function(connection) {
    if (connection.connected)
      connection.sendUTF(data);
  });
  
  client.connect('ws://' + localhost + ':' + eventPort);
}

function notify(addr, key, bridge, args)
{
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function () {
    client.publish(addr, encrypt(args, key));
    client.end();
  });
}

function open(addr, key, bridge, source)
{
  var identity = source.addr;
  
  if (addr in connections) {
    if (connections[addr].identity != identity)
      close(addr);
    else { 
      if (connections[addr].ready)
        trigger(addr);
      return;
    }
  }
  
  var peer = new SimplePeer({
    wrtc: wrtc,
    initiator: true,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  connections[addr] = new Object();
  connections[addr].identity = identity;
  connections[addr].ready = false;
  connections[addr].peer = peer;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.desc = data;
    args.cmd = 'connect';
    args.key = source.key;
    args.addr = source.addr;
    args.bridge = source.bridge;
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('connect', function () {
    connections[addr].ready = true;
    trigger(addr);
  });
  
  peer.on('close', function() {
    if (addr in connections)
      delete connections[addr];
  });
  
  if (source.keep) {
    peer.on('data', function (data) {
      forward(data);
    });
  }
  
  log('open, addr=' + addr);
}

function close(addr) 
{
  if (addr in connections) {
    var peer = connections[addr].peer;
    
    delete connections[addr];
    peer.destroy();
    log("close, addr=" + addr);
  }
}

function connect(addr, key, bridge, desc, identity)
{ 
  if (addr in connections) {
    if (connections[addr].identity != identity)
      close(addr);
    else {
      connections[addr].peer.signal(desc);
      return;
    }
  }
  
  var peer = new SimplePeer({
    wrtc: wrtc,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  connections[addr] = new Object();
  connections[addr].identity = identity;
  connections[addr].ready = false;
  connections[addr].peer = peer;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.desc = data;
    args.cmd = 'accept';
    args.addr = identity;
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('connect', function () {
	connections[addr].ready = true;
  });
  
  peer.on('data', function (data) {
    forward(data);
  });
  
  peer.on('close', function() {
    if (addr in connections)
      delete connections[addr];
  });
  
  peer.signal(desc);
  log('connect, addr=' + addr);
}

function accept(addr, desc, identity)
{
  if (addr in connections && connections[addr].identity == identity) {
    connections[addr].peer.signal(desc);
    log('accept, addr=' + addr);
  }
}

function send(addr, buf)
{
  if (addr in connections && connections[addr].ready && buf) {
    connections[addr].peer.send(buf);
    log('send, addr=' + addr);
  }
}

function attach(addr, key, bridge)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function() {
    client.subscribe(addr);
  });
  
  client.on('message', function(topic, message) {
    var data = decrypt(message.toString(), k, iv);
    var args = JSON.parse(data);
    
    if ('connect' == args.cmd) {
      connect(args.addr, args.key, args.bridge, args.desc, addr);
    } else if ('accept' == args.cmd) {
      accept(args.addr, args.desc, addr);
    } else
      log('failed to attach, invalid command');
  });
  
  listeners[addr] = client;
}

function detach(addr)
{ 
  if (addr in listeners) {
    var client = listeners[addr];
    
    client.unsubscribe(addr);
    client.end();
    delete listeners[addr];
  }
}

function exist(addr, socket)
{
  if (addr in connections && connections[addr].ready) {
    socket.send('exist');
    log('exist, addr=' + addr);
  } else
    socket.send('');
}

if (sourceAddr) {
  attach(sourceAddr, sourceKey, bridgeAddr);
}

if (adapterPort) {
  var source = new Object();
  var websocket = require('ws');
  var server = new websocket.Server({'port': adapterPort});
  
  if (sourceAddr) {
    source.keep = 1;
    source.key = sourceKey;
    source.addr = sourceAddr;
    source.bridge = bridgeAddr;
  }
  
  server.on('connection', function(socket) {
    socket.on('message', function(data) {
      var args = JSON.parse(data);
      
      if (!args.source)
        args.source = source;
      
      if ('open' == args.cmd) {
        open(args.addr, args.key, args.bridge, args.source);
      } else if ('close' == args.cmd) {
        close(args.addr);
      } else if ('attach' == args.cmd) {
        attach(args.addr, args.key, args.bridge);
      } else if ('detach' == args.cmd) {
        detach(args.addr);
      } else if ('exist' == args.cmd) {
        exist(args.addr, socket);
      } else if ('send' == args.cmd) {
        send(args.addr, args.buf);
      }else
        log("invalid command");
    });
  });
}
