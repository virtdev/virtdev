#!/usr/bin/node

// Copyright (C) 2016 Yi-Wei Ci
//
// Distributed under the terms of the MIT license.
//

var mqtt = require('mqtt');
var crypto = require('crypto');
var uuid = require('node-uuid');
var zerorpc = require('zerorpc');
var wrtc = require('electron-webrtc')();
var SimplePeer = require('simple-peer');
var WebSocketClient = require('websocket').client;
var argv = require('minimist')(process.argv.slice(2));

var eventPort = argv.e;
var sourceKey = argv.k;
var sourceAddr = argv.a;
var bridgeAddr = argv.b;
var bridgePort = argv.p;
var adapterPort = argv.l;
var conductorPort = argv.c;
var sendTimeout = parseInt(argv.t) * 1000; //msec

var debug = true;
var pktMark = '|';

var waitTime = 50; // msec
var pktSize = 1 << 26;
var chunkSize = 65536;
var localhost = '127.0.0.1';
var highWaterMark = 1 << 24;
var lowWaterMark = highWaterMark / 2;

var listeners = new Object();
var connections = new Object();
var peerConnections = new Object();

var peerConnectionConfig = {
  iceServers: [
    {url:'stun:stun.ekiga.net'}
  ]
};

var dataChannelConfig = {
  ordered: true,
  reliable: false,
  maxRetransmitTime: 3000
};

function log(str)
{
  if (debug)
    console.log('wrtc: ' + str);
}

function error(str)
{
  console.log('wrtc: ' + str);
}

function encrypt(args, key)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var data = JSON.stringify(args);
  var encipher = crypto.createCipheriv('aes-128-cbc', k, iv);
  var res = encipher.update(data, 'utf8', 'binary');
  
  return res + encipher.final('binary');
}

function decrypt(data, k, iv)
{
  var decipher = crypto.createDecipheriv('aes-128-cbc', k, iv);
  var res = decipher.update(data, 'binary', 'utf8');
  
  return res + decipher.final('utf8');
}

function isReady(addr)
{
  if ((addr in connections) && connections[addr].ready)
    return true;
  else
    return false;
}

function emit(event, args)
{
  var client = new zerorpc.Client();
  
  client.connect('tcp://' + localhost + ':' + eventPort);
  client.invoke('emit', event, args);
  client.close();
}

function notify(addr, key, bridge, args)
{
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function () {
    client.publish(addr, encrypt(args, key));
    client.end();
  });
}

function newPkt(data)
{
  var buf = String(data);
  
  if (buf.indexOf(pktMark) != -1) {
    error('invalid data');
    return;
  }
  
  return buf + pktMark;
}

function int2hex(val)
{
  var hex = val.toString(16);
  
  return "00000000".substr(0, 8 - hex.length) + hex; 
}

function newAckPkt(index)
{
  return pktMark + int2hex(index) + pktMark;
}

function newIndexedPkt(addr, data)
{
  var buf = String(data);
  
  if (buf.indexOf(pktMark) != -1) {
    error('failed to create an indexed packet, addr=' + addr);
    return;
  }
  
  if (!connections[addr].index)
    connections[addr].index = 1;
  else
    connections[addr].index += 1;
  
  var index = connections[addr].index;
  var content = pktMark + int2hex(index) + buf + pktMark;
  
  return {'index':index, 'data':content};
}

function hasPeer(addr, id)
{
  if ((addr in peerConnections) && (id == peerConnections[addr].id))
    return true;
  else
    return false;
}

function hasConnection(addr, id)
{
  if ((addr in connections) && (id == connections[addr].id))
    return true;
  else
    return false;
}

function releasePeer(addr)
{
  if (addr in peerConnections) {
    var peer = peerConnections[addr].peer;
    
    delete peerConnections[addr];
    peer.destroy();
  }
}

function checkPkt(addr, index, id)
{
  if (peerConnections[addr].buf)
    delete peerConnections[addr].buf;
  
  if (!peerConnections[addr].index
  || (id != peerConnections[addr].id)
  || (index > peerConnections[addr].index)) {
    peerConnections[addr].index = index;
    peerConnections[addr].id = id;
    return true;
  } else
    return false;
}

function updatePkt(data, addr, id)
{ 
  if (hasPeer(addr, id)) {
    var buf = String(data);
    
    if (peerConnections[addr].buf) {
      if (peerConnections[addr].buf.length + buf.length >= pktSize) {
        error('failed to update packet, invalid size, addr=' + addr);
        releasePeer(addr);
        return;
      }
      peerConnections[addr].buf += buf;
    } else {
      if (buf.length >= pktSize) {
        error('failed to update packet, invalid size, addr=' + addr);
        releasePeer(addr);
        return;
      }
      peerConnections[addr].buf = buf;
    }
  }
}

function deliver(data, addr, id)
{ 
  if (hasPeer(addr, id)) {
    var buf = String(data);
    var client = new WebSocketClient();
    var index = peerConnections[addr].index;
    
    if (peerConnections[addr].buf) {
      if (peerConnections[addr].buf.length + buf.length >= pktSize) {
        error('failed to deliver, invalid size, addr=' + addr);
        releasePeer(addr);
        return;
      }
      
      buf = peerConnections[addr].buf + buf;
      delete peerConnections[addr].buf;
    } else {
      if (buf.length >= pktSize) {
        error('failed to deliver, invalid size, addr=' + addr);
        releasePeer(addr);
        return;
      }
    }
    
    client.on('connect', function(connection) {
      connection.on('close', function() {
        if (index) {
          if (hasPeer(addr, id))
            peerConnections[addr].peer.send(newAckPkt(index));
          else
            error('failed to deliver, no ACK, addr=' + addr);
        }
      });
      
      if (connection.connected)
        connection.sendUTF(buf);
    });
    
    client.connect('ws://' + localhost + ':' + conductorPort);
  }
}

function checkIndex(addr, index)
{
  if (!connections[addr].ack || (index > connections[addr].ack)) {
    connections[addr].ack = index;
    return true;
  } else
    return false;
}

function deliverPkt(data, addr, id)
{
  var minLen = 10;
  var buf = String(data);
  
  if (buf.startsWith(pktMark)) {
    if (buf.length < minLen) {
      error("failed to deliver packet, invalid length");
      return;
    }
    
    var index = Number('0x' + buf.substring(1, minLen - 1));
    
    if ((buf.length == minLen) && buf.endsWith(pktMark)) {
      if (isReady(addr)) {
        if (checkIndex(addr, index)) {
          emit('put', {'name': addr});
          log('receive an ACK, addr=' + addr + ', index=' + index.toString());
        }
      }
    } else if (checkPkt(addr, index, id)) {
      if (buf.endsWith(pktMark)) {
        deliver(buf.substring(minLen - 1, buf.length - 1), addr, id);
      } else {
        updatePkt(buf.substring(minLen - 1, buf.length), addr, id);
      }
    }
  } else if (buf.endsWith(pktMark)) {
    deliver(buf.substring(0, buf.length - 1), addr, id);
  } else {
    updatePkt(buf, addr, id);
  }
}

function join(dest, src)
{ 
  var id = src.id;
  var key = src.key;
  var addr = src.addr;
  var desc = src.desc;
  var bridge = src.bridge;
  
  if (!id || !key || !addr || !desc || !bridge) {
    error('failed to join, invalid arguments');
    return;
  }
  
  if (addr in peerConnections) {
    if (peerConnections[addr].id != id) {
      var peer = peerConnections[addr].peer;
      
      delete peerConnections[addr];
      peer.destroy();
      log('join, clear connection, addr=' + addr);
    } else {
      peerConnections[addr].peer.signal(desc);
      return;
    }
  }
  
  var peer = new SimplePeer({
    wrtc: wrtc,
    highWaterMark: highWaterMark,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  peerConnections[addr] = new Object();
  peerConnections[addr].peer = peer;
  peerConnections[addr].id = id;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.id = id;
    args.addr = dest;
    args.desc = data;
    args.cmd = 'response';
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('data', function (data) {
    if (data)
      deliverPkt(data, addr, id);
  });
  
  peer.on('close', function() {
    if (hasPeer(addr, id))
      delete peerConnections[addr];
  });
  
  peer.on('error', function (err) {
    if (hasPeer(addr, id)) {
      delete peerConnections[addr];
      peer.destroy();
      error('join, connection is lost, addr=' + addr);
    }
  });
  
  peer.signal(desc);
  log('join, addr=' + addr);
}

function response(dest)
{
  var id = dest.id;
  var addr = dest.addr;
  var desc = dest.desc;
  
  if (!addr || !desc || !id) {
    error('failed to response, invalid arguments');
    return;
  }
  
  if ((addr in connections) && (connections[addr].id == id))
    connections[addr].peer.signal(desc);
}

function connect(addr, key, bridge, source)
{ 
  if (addr in connections) {
    if (connections[addr].src != source.addr) {
      var peer = connections[addr].peer;
      
      delete connections[addr];
      peer.destroy();
    } else {
      if (connections[addr].ready) {
      	emit('connect', {'name':addr});
        log('connect again, addr=' + addr);
      }
      
      return;
    }
  }
  
  var id = uuid.v4();
  var peer = new SimplePeer({
    wrtc: wrtc,
    initiator: true,
    highWaterMark: highWaterMark,
    config: peerConnectionConfig,
    channelConfig: dataChannelConfig
  });
  
  connections[addr] = new Object();
  connections[addr].src = source.addr;
  connections[addr].ready = false;
  connections[addr].peer = peer;
  connections[addr].id = id;
  
  peer.on('signal', function (data) {
    var args = new Object();
    
    args.id = id;
    args.desc = data;
    args.cmd = 'join';
    args.key = source.key;
    args.addr = source.addr;
    args.bridge = source.bridge;
    
    notify(addr, key, bridge, args);
  });
  
  peer.on('connect', function () {
    if (hasConnection(addr, id)) {
      connections[addr].ready = true;
      emit('connect', {'name':addr});
    }
  });
  
  peer.on('close', function() {
    if (hasConnection(addr, id))
      delete connections[addr];
  });
  
  peer.on('error', function (err) {
    if (hasConnection(addr, id)) {
      delete connections[addr];
      peer.destroy();
      error('failed to connect, addr=' + addr);
    }
  });
  
  if (source.listen) {
    peer.on('data', function (data) {
      if (data)
        deliverPkt(data, addr, id);
    });
  }
  
  log('connect, addr=' + addr);
}

function disconnect(addr) 
{
  if (addr in connections) {
    var peer = connections[addr].peer;
    
    delete connections[addr];
    peer.destroy();
    
    log("disconnect, addr=" + addr);
  }
}

function chunkify(addr, data)
{
  var buf = String(data);
  
  if (chunkSize) {
    var start = 0;
    var length = buf.length;
    
    while (start < length) {
      var l = start + chunkSize <= length ? chunkSize : length - start;
      
      if (isReady(addr)) {
        connections[addr].peer.send(buf.substring(start, start + l));
        start += l;
      } else {
        log('failed to chunkify, addr=' + addr);
        return false;
      }
    }
  } else {
    if (isReady(addr))
      connections[addr].peer.send(buf);
    else {
      log('failed to chunkify, addr=' + addr);
      return false;
    }
  }
  
  return true;
}

function addCallback(addr, pkt, callback, event)
{
  var t = 0;
  var waterMark = (highWaterMark + lowWaterMark) / 2;
  var intv = setInterval(function() {
    if (!isReady(addr)) {
      clearInterval(intv);
      emit(event, {'name':addr, 'error':-2});
      log('connection is lost, addr=' + addr);
    } else {
      var size = connections[addr].peer.bufferSize;
      
      t += waitTime;
      if ((t + waitTime >= sendTimeout) || (size < lowWaterMark)) {
        clearInterval(intv);
        if (size < waterMark)
          callback(addr, pkt);
        else
          emit(event, {'name':addr, 'error':-101});
      }
    }
  }, waitTime);
}

function sendPkt(addr, pkt)
{
  if (chunkify(addr, pkt)) {
    emit('send', {'name':addr});
    log('send packet, addr=' + addr);
  } else {
    emit('send', {'name':addr, 'error':-2});
    error('failed to send packet, addr=' + addr);
  }
}

function send(addr, data)
{
  if (isReady(addr)) {
    if (data) {
      var pkt = newPkt(data);
      
      if (!pkt)
        return;
      
      if (!sendTimeout || (connections[addr].peer.bufferSize < lowWaterMark))
        sendPkt(addr, pkt);
      else
        addCallback(addr, pkt, sendPkt, 'send');
    }
  } else
    emit('send', {'name':addr, 'error':-2});
}

function waitAck(addr, pkt)
{
  var t = 0;
  var index = pkt.index;
  var timeout = sendTimeout;
  var intv = setInterval(function () {
    if (!isReady(addr)) {
      clearInterval(intv);
      emit('put', {'name':addr, 'error':-2});
      log('failed to get ACK, connection is lost, addr=' + addr);
    } else {
      t += waitTime;
      if ((connections[addr].ack >= index) || (t >= timeout)) {
        clearInterval(intv);
        if (connections[addr].ack < index)
          emit('put', {'name':addr, 'error':-101});
      }
    }
  }, waitTime);
}

function putPkt(addr, pkt)
{
  if (chunkify(addr, pkt.data)) {
    waitAck(addr, pkt);
    log('put packet, addr=' + addr);
  } else {
    emit('put', {'name':addr, 'error':-2});
    error('failed to put packet, addr=' + addr);
  }
}

function put(addr, data)
{
  if (isReady(addr)) {
    if (data) {
      var pkt = newIndexedPkt(addr, data);
      
      if (!pkt) {
        error('failed to put, addr=' + addr);
        return;
      }
      
      if (!sendTimeout || (connections[addr].peer.bufferSize < lowWaterMark))
        putPkt(addr, pkt);
      else
        addCallback(addr, pkt, putPkt, 'put');
    }
  } else
    emit('put', {'name':addr, 'error':-2});
}

function attach(addr, key, bridge)
{
  var k = key.substring(0, 16);
  var iv = key.substring(16, 32);
  var client = mqtt.connect('mqtt://' + bridge + ':' + bridgePort);
  
  client.on('connect', function() {
    client.subscribe(addr);
  });
  
  client.on('message', function(topic, message) {
    var data = decrypt(message.toString(), k, iv);
    var args = JSON.parse(data);
    
    if ('join' == args.cmd) {
      join(addr, args);
    } else if ('response' == args.cmd) {
      response(args);
    } else
      error('failed to attach, invalid command');
  });
  
  listeners[addr] = client;
}

function detach(addr)
{
  if (addr in listeners) {
    var client = listeners[addr];
    
    delete listeners[addr];
    client.unsubscribe(addr);
    client.end();
    log('detach, addr=' + addr);
  }
}

function exist(addr)
{
  if (isReady(addr)) {
    emit('exist', {'name':addr});
    log('exist, addr=' + addr);
  } else {
    emit('exist', {'name':addr, 'error':-2});
    log("exist, no entry, addr=" + addr);
  }
}

if (sourceAddr)
  attach(sourceAddr, sourceKey, bridgeAddr);

if (adapterPort) {
  var src = new Object();
  
  if (sourceAddr) {
    src.listen = true;
    src.key = sourceKey;
    src.addr = sourceAddr;
    src.bridge = bridgeAddr;
  }
  
  var server = new zerorpc.Server({
    request: function(op, args, reply) {
      if ('connect' == op) {
        if (!args.source)
          connect(args.addr, args.key, args.bridge, src);
        else
          connect(args.addr, args.key, args.bridge, args.source);
      } else if ('disconnect' == op) {
        disconnect(args.addr);
      } else if ('attach' == op) {
        attach(args.addr, args.key, args.bridge);
      } else if ('detach' == op) {
        detach(args.addr);
      } else if ('exist' == op) {
        exist(args.addr);
      } else if ('send' == op) {
        send(args.addr, args.buf);
      } else if ('put' == op) {
        put(args.addr, args.buf);
      }else
        error("invalid command");
      reply();
    }
  });
  
  server.bind('tcp://' + localhost + ':' + adapterPort);
}
